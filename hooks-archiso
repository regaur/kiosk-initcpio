
run_hook () {
  # we expect to find a file containing the ESP volume uuid
  if [[ -f /efi_volume_id ]]; then
    efi_volume_id=$(cat /efi_volume_id)
    msg ":: Found /efi_volume_id: ${efi_volume_id}"
    [[ -z "${archisodevice}" ]] && archisodevice="/dev/disk/by-uuid/${efi_volume_id}"
  else
    msg ":: Did not find /efi_volume_id"
  fi
  if ! mountpoint -q "/run/archiso/bootmnt"; then
    _mnt_dev "${archisodevice}" "/run/archiso/bootmnt" "-r" "defaults"
  fi

  local luks_img="/run/archiso/bootmnt/luks.img"
 
  if [[ -e "${luks_img}" ]]; then
      local luks_dev=$(losetup --find --show --read-only "${luks_img}")

      # setting global variables to be picked up by encrypt-hook
      cryptdevice=${luks_dev}:squashfs
      msg ":: New cryptdevice is ${cryptdevice}"

      root=/dev/mapper/squashfs
      msg ":: New root is ${root}"
  else
    # we do not set cryptdevice, so the encrypt hook will ignore us
    # out loopmount hook will pick this up and add an overlay
    unset cryptdevice
  fi
  rootfstype=squashfs
  msg ":: New rootfstype is ${rootfstype}"
}

# args: device, mountpoint, flags, opts
_mnt_dev() {
    local dev="${1}"
    local mnt="${2}"
    local flg="${3}"
    local opts="${4}"

    mkdir -p "${mnt}"

    msg ":: Mounting '${dev}' to '${mnt}'"

    while ! poll_device "${dev}" 30; do
        echo "ERROR: '${dev}' device did not show up after 30 seconds..."
        echo "   Falling back to interactive prompt"
        echo "   You can try to fix the problem manually, log out when you are finished"
        launch_interactive_shell
    done

    if mount -o "${opts}" "${flg}" "${dev}" "${mnt}"; then
        msg ":: Device '${dev}' mounted successfully."
    else
        echo "ERROR; Failed to mount '${dev}'"
        echo "   Falling back to interactive prompt"
        echo "   You can try to fix the problem manually, log out when you are finished"
        launch_interactive_shell
    fi
}

# vim:ft=sh:ts=4:sw=4:et:
